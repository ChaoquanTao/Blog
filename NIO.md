---
layout: java
title: 谈一谈Java NIO
date: 2019-07-17 16:30:42
tags: Java
categories: Java
---

NIO(Non-Blocking IO，非阻塞同步IO)是Jdk 1.4后提出的新技术，为什么要提出这个技术呢？是为了解决什么问题呢？

要回答这个问题，就要从传统的阻塞式IO说起。

#### 何为同步异步，何为阻塞非阻塞

对IO来说，

+ 同步：API调用返回时就已经知道执行结果了

+ 异步：API调用返回时还不知道执行结果，需要过一会儿才能知道
+ 阻塞：当没有数据读或者写时，它就一直等啊等，等到有数据来
+ 非阻塞：能读多少是多少，然后返回，即使没有数据读，我也不等，直接返回

#### 传统IO

1. ##### 单线程下的通信

我们举个简单例子，为了读取一个TCP连接的数据，你调用InputStream的read方法，这会使当前线程一直阻塞，知道有新的数据来。当前线程一直被挂起，占用着内存资源。等到当前的连接结束后再开始下一轮的接客，很显然，这是很低效的，

2. ##### 多线程下的通信

后来，生活改善了，我们多开几个线程，每次有新的连接来了我就重新创建一个线程，而不是排队等候那唯一一个线程，嗯，效率得到了提高。

3. ##### 线程太多啦

再后来，业务庞大了，连接数多了起来，这么频繁的创建销毁线程也是很消耗系统资源的，于是，提出了线程池的概念，在营业之前我先创建好一系列线程，到时候有连接来了我就分配一个线程，用完了我再拿回来，性能薛微得到了一丝改善。

4. ##### 线程池也扛不住了

业务持续增长，线程池也满足不了需求了，当线程数大于cpu核数的时候，必然会存在线程切换的问题，这很耗费资源，而且，对于每个线程内部，阻塞的情况还是存在的，这也就存在一个线程状态切换的问题，这也耗费资源。



基于这个背景，我们就在考虑，有没有什么方法，能够解决这个线程频繁上下文切换的问题？也就有了我们的NIO

##### NIO

NIO是怎么工作的呢？首先，它是非阻塞的，非阻塞意味着读或者写的时候，如果没有数据，就直接返回了。为了能够拿到数据，你可能就要不停的去调用read或者write去尝试看能不能拿到数据。这也是NIO需要解决的问题之一。

它的设计思想是这样的：

+ 单线程实现

+ 提出了`Channel`的概念，每一个对磁盘或者文件的IO操作对应一个Channel，相当于Channel提供了我们和真正的文件或者磁盘操作的一个桥梁。

+ 我们通过Buffer和Channel交互，对于读操作，我们先把数据从Channel读到Buffer,然后再操作Buffer, 对于写操作，我们先把数据放到Buffer, 然后再写到Channel.
+ 为了在实现非阻塞的同时避免不停的调用read()或者write(), 实现了监听机制。具体是通过选择器Selector实现的，我们把每个Channel都绑定在一个Selector上，并且告诉Selector我对什么样的事件感兴趣，通过Selector进行监听，监听的过程中程序是阻塞的，当Channel感兴趣的事件发生时，Selector通知Channel,然后Channel开始它的表演。

所以，说白了，它的非阻塞同步，主要就是

1. 设置了监听
2. 把多线程的客户端请求映射成了单线程的多个channel, 然后selector监听，有感兴趣的事情发生之后就开始轮询每个channel.