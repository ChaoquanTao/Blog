---
title: KMP算法
date: 2020-01-04 22:10:34
updated: 2020-01-04 22:10:34
tags: KMP
categories: 数据结构与算法
---

 这里谈一下我对KMP算法的理解。

字符串匹配中，暴力方法是这样的：用模式串和文本串挨个比对，这一过程其实是有很多重复的，而KMP算法的核心正是跳过这些重复比对的字符，那么就需要一定的空间来记录比对过的历史了，这也就是next数组的意义所在。

当文本串的第i个字符和模式串的第j个字符失配时，我们真的要把模式串统一向文本串右移一位对齐然后继续比较吗，答案是不必的。当此处失配时，我们应该考虑失配的地方的前几位和模式串的开头几位有没有一样的，如果有，那就是可以直接将模式串移动过来了，这就是所谓的最长前缀后缀了，

![undefined](http://ww1.sinaimg.cn/large/005UcYzagy1gakw4sdwvoj30g103ma9x.jpg)

看，这里文本串的空格和模式串的D失配了，但是你会发现，失配之前，文本串的屁股AB和模式串的开头AB是匹配的，这意味着什么，我们可以直接把模式串移动到开头和失配之前文本串的屁股AB对齐的那里。

![undefined](http://ww1.sinaimg.cn/large/005UcYzagy1gakw7atagbj30g503tdfp.jpg)

像这样，是不是一下子少走了好几步？所以这个KMP的关键问题就变成了如何构建next数组，即如何计算最大公共前缀后缀。

 对于P的前j+1个序列字符：

+ 若p[k] == p[j]，则next[j + 1 ] = next [j] + 1 = k + 1；
+ 若p[k ] ≠ p[j]，如果此时p[ next[k] ] == p[j ]，则next[ j + 1 ] =  next[k] + 1，否则继续递归前缀索引k = next[k]，而后重复此过程。 相当于在字符p[j+1]之前不存在长度为k+1的前缀"p0 p1, …, pk-1 pk"跟后缀“pj-k pj-k+1, …, pj-1 pj"相等，那么是否可能存在另一个值t+1 < k+1，使得长度更小的前缀 “p0 p1, …, pt-1 pt” 等于长度更小的后缀 “pj-t pj-t+1, …, pj-1 pj” 呢？如果存在，那么这个t+1 便是next[ j+1]的值，此相当于利用已经求得的next 数组（next [0, ..., k, ..., j]）进行P串前缀跟P串后缀的匹配。
  